

from __future__ import annotations

from pathlib import Path
from typing import Dict, Any

import joblib
import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.impute import SimpleImputer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import (
    brier_score_loss,
    mean_absolute_error,
    mean_squared_error,
    roc_auc_score,
)
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
import test

from power_data import (
    TARGET_PARAM,
    EXTRA_PARAMS,
    BBOX_TORONTO,
    get_dataset,
    split_by_years,
)

BASE_DIR = Path(__file__).resolve().parent              # → nasa-app/data-modeling
ARTIFACTS_DIR = BASE_DIR / "artifacts"
ARTIFACTS_DIR.mkdir(parents=True, exist_ok=True)

def main():
    # === Load the shared dataset (one-liner) ===
    bundle = get_dataset(years=5, bbox=BBOX_TORONTO, target_param=TARGET_PARAM, extra_params=EXTRA_PARAMS)

    data = bundle.data
    climo_cols = bundle.climo_cols

    # === Split: proportions by years (chronological) ===
    train_df, val_df, test_df = split_by_years(data, train=0.6, val=0.2, test=0.2, chronological=True)

    # === Feature set ===
    X_cols = ["lat", "lon", "doy_sin", "doy_cos"] + climo_cols
    y_cls = "rain_flag"
    y_reg = "y_log1p"

    def XY(df):
        return df[X_cols], df[y_cls].astype(int)

    def XR(df):
        m = df[y_cls] == 1
        return df.loc[m, X_cols], df.loc[m, y_reg]

    Xtr, ytr = XY(train_df)
    Xva, yva = XY(val_df)
    Xte, yte = XY(test_df)

    Xtr_r, ytr_r = XR(train_df)
    Xva_r, yva_r = XR(val_df)
    Xte_r, yte_r = XR(test_df)

    print(f"Features: {len(X_cols)}  | Train rows: {len(train_df):,}  | Rain-only rows: {len(Xtr_r):,}")

    # extract a csv out ouf testing data with lat, lon and corresponding targets
    test_output = test_df[["lat", "lon", "doy_sin", "doy_cos", y_cls, y_reg]]
    day_angle = np.arctan2(test_output["doy_sin"], test_output["doy_cos"])
    # Map from radians (-π → π) to 0–2π
    day_angle = (day_angle + 2 * np.pi) % (2 * np.pi)

    # Convert to day‑of‑year (1–365)
    test_output["doy_estimated"] = (day_angle * 365 / (2 * np.pi)).round().astype(int)
    test_output = test_output.drop(columns=["doy_sin", "doy_cos"])
        
    test_output.to_csv(ARTIFACTS_DIR / "test_data.csv", index=False)
    
    
   



if __name__ == "__main__":
    main()
